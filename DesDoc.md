# Дизайн-документ: Інтерпретатор LOLCODE на Python

**Версія:** 1.0  
**Автор:** Гордієнко Роман, Лаврик Севастьян, Ухалов Олексій  
**Дата:** 25.05.2024

---

## 1. Вступ

### 1.1. Мета документа
Цей документ описує архітектуру, дизайн та реалізацію інтерпретатора для підмножини мови програмування LOLCODE, написаного на Python. 
Мета проєкту — створити простий, розширюваний та зрозумілий інтерпретатор, що демонструє класичні етапи обробки мови програмування: лексичний аналіз, синтаксичний аналіз та виконання (інтерпретацію).

### 1.2. Опис проєкту
Проєкт "LOLPython" є інтерпретатором, який приймає на вхід текстовий файл з кодом на LOLCODE, обробляє його та виводить результат у консоль. 
Він реалізує базові можливості мови, такі як оголошення змінних, присвоєння, арифметичні операції та вивід даних.

### 1.3. Цільова аудиторія
Цей проєкт розрахований на:
*   Студентів, що вивчають теорію компіляторів.
*   Розробників, які хочуть зрозуміти принципи роботи інтерпретаторів.
*   Ентузіастів, зацікавлених у езотеричних мовах програмування.

---

## 2. Цілі та Не-цілі

### 2.1. Цілі (Goals)
*   **Реалізувати лексер**, який розбиває вихідний код на потік токенів.
*   **Реалізувати парсер**, який будує з потоку токенів Абстрактне Синтаксичне Дерево (AST).
*   **Визначити структуру AST** за допомогою `dataclasses` для чіткості та простоти.
*   **Реалізувати інтерпретатор**, який обходить AST (tree-walking interpreter) та виконує код.
*   **Підтримати базовий синтаксис LOLCODE 1.2:**
    *   Оголошення програми (`HAI 1.2`, `KTHXBYE`).
    *   Оголошення змінних (`I HAS A ... [ITZ ...]`).
    *   Присвоєння (`... R ...`).
    *   Вивід у консоль (`VISIBLE ...`).
    *   Арифметичні та логічні операції (`SUM OF`, `DIFF OF`, `PRODUKT OF`, `QUOSHUNT OF`, `BOTH SAEM`, `DIFFRINT`).
    *   Базові типи даних: `NUMBR` (числа), `YARN` (рядки), `TROOF` (булеві).
*   **Створити чітку систему обробки помилок** для кожного етапу (лексичного, синтаксичного, виконання).

### 2.2. Не-цілі (Non-Goals)
*   **Повна відповідність специфікації LOLCODE 1.2.** Проєкт реалізує лише підмножину мови. Такі конструкції, як цикли (`IM IN YR`), умови (`O RLY?`), функції (`HOW DUZ I`) та складніші типи, не входять до поточної версії.
*   **Висока продуктивність.** Проєкт є навчальним, тому пріоритет надається зрозумілості коду, а не швидкості виконання.
*   **Компіляція у байт-код або машинний код.** Проєкт є чистим інтерпретатором, а не компілятором.
*   **Розширена статична аналітика або перевірка типів.** Перевірка типів відбувається динамічно під час виконання.

---

## 3. Архітектура та Компоненти

Проєкт має класичну архітектуру для інтерпретатора, що складається з послідовних етапів обробки.


### 3.1. Лексер (`lexer.py`)
**Відповідальність:** Перетворення рядка з вихідним кодом на послідовність (список) токенів.

**Реалізація:** Лексер використовує регулярні вирази (`re`) для ідентифікації лексем. Список `token_specs` визначає пари (тип токена, шаблон regex). Лексер ітеративно проходить по коду, знаходячи відповідності.

**Ключова структура:** `Token` — іменований кортеж (`namedtuple`), що зберігає `type`, `value`, `line` та `column`. Це забезпечує незмінність токенів та легкий доступ до їх атрибутів.

**Обробка помилок:** Якщо жоден шаблон не відповідає поточній позиції в коді, генерується виняток `LexerError`. Пробіли та коментарі (`BTW...`) ігноруються.

### 3.2. Парсер (`parser.py`)
**Відповідальність:** Побудова Абстрактного Синтаксичного Дерева (AST) з послідовності токенів, перевіряючи відповідність коду граматиці мови.

**Реалізація:** Використовується метод рекурсивного спуску (Recursive Descent Parser). Кожен нетермінал граматики реалізований як окремий метод (наприклад, `_parse_statement`, `_parse_expression`).

**Ключові методи:**
*   `parse()`: Головний метод, що запускає аналіз.
*   `_eat(token_type)`: Перевіряє, чи поточний токен має очікуваний тип, і зсуває позицію. В іншому випадку — `ParserError`.
*   `_parse_...()`: Методи для розбору конкретних конструкцій мови.

**Обробка помилок:** `ParserError` генерується при порушенні синтаксичних правил (наприклад, несподіваний токен).

### 3.3. Абстрактне Синтаксичне Дерево (AST) (`ast_nodes.py`)
**Відповідальність:** Представлення структури програми у вигляді ієрархічної структури даних (дерева).
**Реалізація:** Для визначення вузлів AST використовуються датакласи (`@dataclass`). Це сучасний підхід у Python, який автоматично генерує `__init__`, `__repr__` та інші методи, роблячи код вузлів чистим і декларативним.
**Ієрархія вузлів:**
*   `ASTNode` (базовий клас)
*   `StatementNode` (для інструкцій)
*   `VarDeclNode`, `AssignmentNode`, `VisibleNode`
*   `ExpressionNode` (для виразів)
*   `LiteralNode`, `IdentifierNode`, `BinaryOpNode`
*   `ProgramNode` (кореневий вузол)

### 3.4. Інтерпретатор (`interpreter.py`)
**Відповідальність:** Виконання коду, представленого у вигляді AST.

**Реалізація:** Використовується патерн "Відвідувач" (Visitor). Головний метод `interpret(node)` динамічно викликає спеціалізований метод `_visit_NodeType(node)` залежно від типу вузла.

**Управління станом:** Інтерпретатор має **таблицю символів** (`symbol_table`) — словник, що зберігає імена змінних та їхні поточні значення.

**Обробка помилок:** `InterpreterError` генерується при помилках часу виконання (runtime errors), таких як використання неоголошеної змінної, ділення на нуль або операції над несумісними типами.

### 3.5. Обробка Помилок (`errors.py`)
**Відповідальність:** Надання єдиної ієрархії винятків для всього проєкту.

**Реалізація:** 
* `LOLPythonError`: Базовий клас для всіх помилок інтерпретатора.
*   `LexerError`, `ParserError`, `InterpreterError`: Специфічні класи для кожного етапу, що успадковуються від базового. Це дозволяє централізовано відловлювати всі помилки проєкту (`except LOLPythonError`).

### 3.6. Головний модуль (`main.py`)
**Відповідальність:** Точка входу в програму. Пов'язує всі компоненти разом.
**Функціональність:** 
1.  Обробляє аргументи командного рядка (очікує шлях до файлу).
2.  Читає вихідний код з файлу.
3.  Послідовно викликає лексер, парсер та інтерпретатор.
4.  Відловлює всі можливі помилки (`LOLPythonError` та інші) і виводить інформативні повідомлення у `stderr`.

---

## 4. Модель Даних

**`Token` (`namedtuple`):** Незмінна структура для представлення лексем. Поля: `type`, `value`, `line`, `column`.

**Вузли AST (`dataclass`):** Об'єкти, що представляють елементи мови. Їхня ієрархія та атрибути чітко визначені у `ast_nodes.py`.

**Таблиця символів (`dict`):** Простий словник Python для зберігання стану змінних (ім'я -> значення).

---

## 5. Підмножина мови LOLCODE, що підтримується

| Конструкція | Синтаксис LOLCODE | Приклад |
|---|---|---|
| **Програма** | `HAI 1.2 ... KTHXBYE` | `HAI 1.2 ... KTHXBYE` |
| **Коментар** | `BTW ...` | `BTW this is a comment` |
| **Оголошення** | `I HAS A <var>` | `I HAS A myVar` |
| **Ініціалізація**| `I HAS A <var> ITZ <expr>` | `I HAS A num ITZ 10` |
| **Присвоєння** | `<var> R <expr>` | `myVar R "hello"` |
| **Вивід** | `VISIBLE <expr1> [<expr2> ...]` | `VISIBLE "Result is:" anVar` |
| **Додавання** | `SUM OF <expr1> AN <expr2>` | `SUM OF 5 AN 3` |
| **Віднімання** | `DIFF OF <expr1> AN <expr2>` | `DIFF OF 10 AN 4` |
| **Множення** | `PRODUKT OF <expr1> AN <expr2>`| `PRODUKT OF 2 AN 6` |
| **Ділення** | `QUOSHUNT OF <expr1> AN <expr2>`| `QUOSHUNT OF 8 AN 2` |
| **Рівність** | `BOTH SAEM <expr1> AN <expr2>` | `BOTH SAEM x AN 5` |
| **Нерівність** | `DIFFRINT <expr1> AN <expr2>` | `DIFFRINT y AN "FAIL"` |

---

## 6. Потенційні Покращення та Майбутня Робота

**Розширення мови:**
*   Додати умовні конструкції (`O RLY?`, `YA RLY`, `NO WAI`, `OIC`).
*   Реалізувати цикли (`IM IN YR ... IM OUTTA YR`).
*   Додати підтримку функцій (`HOW DUZ I ... IF U SAY SO`).

**Покращення системи типів:**
*   Ввести більш сувору перевірку типів під час виконання.
*   Реалізувати автоматичне приведення типів (type casting), як це визначено у специфікації LOLCODE.

**Оптимізація:**
*   Перехід від tree-walking інтерпретатора до компіляції в байт-код з подальшим виконанням на віртуальній машині (VM). Це значно прискорить виконання циклів.

**Покращення обробки помилок:**
*   Додавати у повідомлення про помилки не тільки номер рядка та колонки, але й сам рядок коду з вказівником на помилку.

**Інтерактивний режим (REPL):**
*   Створити REPL (Read-Eval-Print Loop) для інтерактивної роботи з інтерпретатором.

**Розширення стандартної бібліотеки:**
*   Реалізувати більше вбудованих функцій, наприклад, для вводу даних (`GIMMEH`).
 
---
